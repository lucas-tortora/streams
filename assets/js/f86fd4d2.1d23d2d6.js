"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[15],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(t),m=a,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return t?r.createElement(h,s(s({ref:n},d),{},{components:t})):r.createElement(h,s({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=u;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var c=2;c<i;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7333:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return u}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),s=["components"],o={},l="Getting Started",c={unversionedId:"libraries/rust/getting_started",id:"libraries/rust/getting_started",isDocsHomePage:!1,title:"Getting Started",description:"Streams requires an asynchronous runtime environment to be set (we suggest using tokio). Streams also uses",source:"@site/docs/libraries/rust/getting_started.md",sourceDirName:"libraries/rust",slug:"/libraries/rust/getting_started",permalink:"/streams/docs/libraries/rust/getting_started",editUrl:"https://github.com/iotaledger/streams/tree/dev/documentation/docs/libraries/rust/getting_started.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Examples",permalink:"/streams/docs/libraries/rust/examples"},next:{title:"API Reference",permalink:"/streams/docs/libraries/rust/api_reference"}},d=[{value:"Basic Usage",id:"basic-usage",children:[{value:"Author Implementation",id:"author-implementation",children:[]},{value:"Subscriber Implementation",id:"subscriber-implementation",children:[]}]},{value:"Next Steps",id:"next-steps",children:[{value:"Subscription",id:"subscription",children:[]},{value:"Keyloads",id:"keyloads",children:[]},{value:"Pre-Shared Keys",id:"pre-shared-keys",children:[]}]}],p={toc:d};function u(e){var n=e.components,t=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"Streams requires an asynchronous runtime environment to be set (we suggest using ",(0,i.kt)("inlineCode",{parentName:"p"},"tokio"),"). Streams also uses\n",(0,i.kt)("inlineCode",{parentName:"p"},"anyhow")," for error handling, so for ease of use, new projects can use ",(0,i.kt)("inlineCode",{parentName:"p"},"anyhow::Result")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"anyhow::Error"),"\nfor easier integration. "),(0,i.kt)("p",null,"If you don't have a rust project setup yet you can create one by running,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"cargo new my-library\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Remote"),"\nAdd the following to your ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'[dependencies]\ntokio = { version = "1.5.0", features = ["full"] }\nanyhow = { version = "1.0", default-features = false }\niota-streams = { git = "https://github.com/iotaledger/streams", branch  = "master"}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Local")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Clone the streams repository"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/iotaledger/streams\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add the following to your ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'[dependencies]\niota-streams = { version = "0.1.2", path = "../streams" }\n')))),(0,i.kt)("h2",{id:"basic-usage"},"Basic Usage"),(0,i.kt)("p",null,"Once installed, users can implement their author and subscribers and start a new channel."),(0,i.kt)("h3",{id:"author-implementation"},"Author Implementation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'use iota_streams::app_channels::api::tangle::{Author, ChannelType};\nuse iota_streams::app::transport::tangle::client::Client;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let node = "https://chrysalis-nodes.iota.org";\n    let client = Client::new_from_url(node);\n\n    // Author implementation will set the Channel Type\n    let mut author = Author::new("AUTHORS_UNIQUE_SEED", ChannelType::SingleBranch, client);\n    \n    // Start the channel and retrieve the announcement address link\n    let ann_address = author.send_announce()?;   \n\n    // Convert the announcement address to a string to share with others\n    println!("{}", ann_address.to_string()); \n}\n')),(0,i.kt)("h3",{id:"subscriber-implementation"},"Subscriber Implementation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'use iota_streams::app_channels::api::tangle::{Address, Subscriber};\nuse iota_streams::app::transport::tangle::client::Client;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    let node = "https://chrysalis-nodes.iota.org";\n    let client = Client::new_from_url(node);\n\n    // Subscriber implementation does not need to specify a channel type, it will be \n    // parsed from the announcement message\n    let mut subscriber = Subscriber::new("SUBSCRIBER_UNIQUE_SEED", client);\n    \n    // Create Address object from announcement address string\n    let ann_address = Address::from_str("Announcement link address provided by author")?;   \n\n    // Process the announcement message\n    subscriber.receive_announcement(ann_address)?;\n}\n')),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"From here you can now begin subscribing users to the channel and generating branches to specify access control\nfor publishers/readers via ",(0,i.kt)("inlineCode",{parentName:"p"},"Keyload")," messages.  "),(0,i.kt)("h3",{id:"subscription"},"Subscription"),(0,i.kt)("p",null,"Subscribers generate their ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscribe")," messages linked to a channel ",(0,i.kt)("inlineCode",{parentName:"p"},"Announce")," message. The link of this message\nshould then be provided to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," for processing to include the users public key for access control and\nvalidation purposes."),(0,i.kt)("p",null,"Example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Subscriber: \n// Send subscription message\nlet sub_link = subscriber.send_subscribe(&ann_address)?;\n// Provide this link to the author\nprintln!("{}", sub_link.to_string());\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Author: \n// Process subscriber link \nlet sub_link = Address::from_str("Sub link provided by desired subscriber")?;\nauthor.receive_subscribe(&sub_link)?;\n')),(0,i.kt)("h3",{id:"keyloads"},"Keyloads"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Keyload")," messages are used as an access control mechanism for a branch. A random key is generated and masked within the\nmessage using the public keys or ",(0,i.kt)("inlineCode",{parentName:"p"},"Psk"),"'s included in them. This allows the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," to specify which channel\nparticipants have access to which branches. There are 2 ways to send a keyload: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"send_keyload(&Address, &Vec<PskId>, &Vec<PublicKey>)")," - In this function you need to specify:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the message link that the ",(0,i.kt)("inlineCode",{parentName:"li"},"Keyload")," message will be attached to (for generating new branches, this should be the\n",(0,i.kt)("inlineCode",{parentName:"li"},"Announce")," message) "),(0,i.kt)("li",{parentName:"ul"},"a slice containing the ",(0,i.kt)("inlineCode",{parentName:"li"},"PskId"),"'s of the Pre-Shared Keys intended to be included "),(0,i.kt)("li",{parentName:"ul"},"a slice containing the ",(0,i.kt)("inlineCode",{parentName:"li"},"ed25519::PublicKey"),"'s of each ",(0,i.kt)("inlineCode",{parentName:"li"},"Subscriber")," that is meant to be granted access "))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"send_keyload_for_everyone(&Address)")," - In this function you only need to specify the message link that the ",(0,i.kt)("inlineCode",{parentName:"li"},"Keyload"),"\nwill be attaching to. The ",(0,i.kt)("inlineCode",{parentName:"li"},"Keyload")," will be sent including all stored ",(0,i.kt)("inlineCode",{parentName:"li"},"PSK"),"'s and all stored ",(0,i.kt)("inlineCode",{parentName:"li"},"Subscriber")," public keys ")),(0,i.kt)("p",null,"Example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Send Keyload for everyone (starting a new branch) \nauthor.send_keyload_for_everyone(&announcement_link)?;\n\n// Send Keyload including Pre Shared Key 2 \nauthor.send_keyload(&announcement_link, &vec![PskId2], &vec![])?;\n\n// Send Keyload for Subscriber 3\nauthor.send_keyload(&announcement_link, &vec![], &vec![subscriber_3_pub_key])?;\n")),(0,i.kt)("h3",{id:"pre-shared-keys"},"Pre-Shared Keys"),(0,i.kt)("p",null,"As an alternative to subscribing via public key exchange, an ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," may specify access control through the use of\na Pre-Shared Key (",(0,i.kt)("inlineCode",{parentName:"p"},"PSK"),"). A ",(0,i.kt)("inlineCode",{parentName:"p"},"PSK")," is a 32 byte array containing a secret key shared outside of the streams instance\nthat can be used to specify access through a ",(0,i.kt)("inlineCode",{parentName:"p"},"Keyload")," message. If an ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," issues a ",(0,i.kt)("inlineCode",{parentName:"p"},"Keyload")," with a ",(0,i.kt)("inlineCode",{parentName:"p"},"PSK")," included,\nand a ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscriber")," reads this message with the same ",(0,i.kt)("inlineCode",{parentName:"p"},"PSK")," stored within itself, then the ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscriber")," can participate in\nthe proceeding branch without being subscribed to the channel. "),(0,i.kt)("p",null,"Example: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Create a random key (for example) and make the Psk from it\nlet key = rand::thread_rng().gen::<[u8; 32]>();\nlet psk = iota_streams::core::psk::Psk::clone_from_slice(&key);\n\n// Store the psk and retrieve the pskid\nlet pskid = author.store_psk(psk.clone());\n\n// Create a keyload with the psk included\nlet keyload_link = author.send_keyload(&prev_msg_link, &vec![pskid], &vec![])?;\n\n// Store the same psk in subscriber \nlet _sub_pskid = subscriber.store_psk(psk);\n\n// Process keyload message from subscriber end\nsubscriber.receive_keyload(&keyload_link)?;\n")))}u.isMDXComponent=!0}}]);